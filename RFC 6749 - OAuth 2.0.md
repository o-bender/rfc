Internet Engineering Task Force (IETF)                     D. Hardt, Ed.
Request for Comments: 6749                                     Microsoft
Obsoletes: [5849](https://datatracker.ietf.org/doc/html/rfc5849)                                             October 2012
Category: Standards Track
ISSN: 2070-1721

# The OAuth 2.0 Authorization Framework
Платформа авторизации OAuth 2.0 позволяет стороннему приложению получать ограниченный доступ к HTTP-сервису либо от имени владельца ресурса, организуя взаимодействие по утверждению между владельцем ресурса и HTTP-сервисом, либо позволяя стороннему приложению получать доступ от своего собственного имени. Эта спецификация заменяет протокол OAuth 1.0, описанный в RFC 5849, и делает его устаревшим.

- [[#Введение|Введение]]
	- [[#Введение#1. 1 Роли|1. 1 Роли]]
	- [[#Введение#1.2 Процесс работы протокола|1.2 Процесс работы протокола]]
	- [[#Введение#1.3 Разрешение авторизации (authorization grant)|1.3 Разрешение авторизации (authorization grant)]]
		- [[#1.3 Разрешение авторизации (authorization grant)#1.3.1 Код авторизации - Authorization Code|1.3.1 Код авторизации - Authorization Code]]
		- [[#1.3 Разрешение авторизации (authorization grant)#1.3.2 Неявный - Implicit|1.3.2 Неявный - Implicit]]
		- [[#1.3 Разрешение авторизации (authorization grant)#1.3.3 Учетные данные пароля владельца ресурса -  Resource Owner Password Credentials|1.3.3 Учетные данные пароля владельца ресурса -  Resource Owner Password Credentials]]
		- [[#1.3 Разрешение авторизации (authorization grant)#1.3.4 Учетные данные клиента -  Client Credentials|1.3.4 Учетные данные клиента -  Client Credentials]]
	- [[#Введение#1.4 Токен доступа - Access token|1.4 Токен доступа - Access token]]
	- [[#Введение#1.5 Токен обновления - refresh token|1.5 Токен обновления - refresh token]]
	- [[#Введение#1.6  Версии TLS|1.6  Версии TLS]]
	- [[#Введение#1.7 HTTP перенаправления|1.7 HTTP перенаправления]]
	- [[#Введение#1.8 Совместимость|1.8 Совместимость]]


## Введение
В традиционной клиент-серверной модели аутентификации клиент запрашивает ресурс с ограниченным доступом (защищенный ресурс) на сервере, проходя аутентификацию на сервере с использованием учетных данных владельца ресурса. Чтобы предоставить сторонним приложениям доступ к ресурсам с ограниченным доступом, владелец ресурса предоставляет свои учетные данные третьей стороне. Это создает ряд проблем и ограничений:
- Сторонние приложения должны сохранять учетные данные владельца ресурса для использования в будущем, обычно это пароль в виде открытого текста.
- Серверы должны поддерживать аутентификацию по паролю, несмотря на недостатки безопасности, присущие паролям.
- Сторонние приложения получают чрезмерно широкий доступ к защищенным ресурсам владельца ресурса, в результате чего владельцы ресурсов не имеют возможности ограничить срок действия или доступ к ограниченному набору ресурсов.
- Владельцы ресурсов не могут отозвать доступ к отдельному третьему лицу, не отозвав доступ ко всем третьим лицам, и должны сделать это, изменив пароль третьего лица.
- Компрометация любого стороннего приложения приводит к компрометации пароля конечного пользователя и всех данных, защищенных этим паролем.

OAuth решает эти проблемы, вводя уровень авторизации и отделяя роль клиента от роли владельца ресурса.  В OAuth клиент запрашивает доступ к ресурсам, контролируемым владельцем ресурса и размещенным на сервере ресурсов, и получает набор учетных данных, отличный от набора учетных данных владельца ресурса.
Вместо использования учетных данных владельца ресурса для доступа к защищенным ресурсам клиент получает токен доступа - строку, обозначающую конкретную область действия, срок службы и другие атрибуты доступа.  Токены доступа выдаются сторонним клиентам сервером авторизации с одобрения владельца ресурса. Клиент использует токен доступа для доступа к защищенным ресурсам, размещенным на сервере ресурсов.
Например, конечный пользователь (владелец ресурса) может предоставить службе печати (клиенту) доступ к своим защищенным фотографиям, хранящимся в службе обмена фотографиями (сервере ресурсов), не сообщая службе печати свое имя пользователя и пароль. Вместо этого конечный пользователь проходит проверку подлинности непосредственно на сервере авторизации, которому доверяет служба обмена фотографиями, который выдает службе печати учетные данные для делегирования полномочий (токен доступа).
Эта спецификация предназначена для использования с HTTP ([RFC2616]).  Использование OAuth по любому протоколу, отличному от HTTP, выходит за рамки.
Протокол OAuth 1.0 ([RFC5849]), опубликованный в качестве информационного документа, стал результатом небольших специальных усилий сообщества.  Эта спецификация отслеживания стандартов основана на опыте внедрения OAuth 1.0, а также на дополнительных вариантах использования и требованиях к расширяемости, собранных более широким сообществом IETF.  Протокол OAuth 2.0 не имеет обратной совместимости с OAuth 1.0. Эти две версии могут сосуществовать в сети, и реализации могут выбрать поддержку обеих. Однако в данной спецификации предполагается, что новые реализации поддерживают OAuth 2.0, как указано в этом документе, и что OAuth 1.0 используется только для поддержки существующих развертываний.  Протокол OAuth 2.0 имеет очень мало общих деталей реализации с протоколом OAuth 1.0.  Разработчики, знакомые с OAuth 1.0, должны подходить к этому документу без каких-либо предположений относительно его структуры и деталей.
### 1. 1 Роли
OAuth определяет четыре роли: 
- владелец ресурса (resource owner) - Организация, способная предоставлять доступ к защищенному ресурсу. Если владельцем ресурса является физическим лицом, он называется конечным пользователем.
- сервер ресурсов (resource server) - Сервер, на котором размещены защищенные ресурсы, способный принимать запросы на защищенные ресурсы и отвечать на них с использованием токенов доступа.
- клиент (client) - Приложение, выполняющее запросы к защищенным ресурсам от имени владельца ресурса и с его разрешения. Термин "клиент" не подразумевает каких-либо конкретных характеристик реализации (например, независимо от того, выполняется ли приложение на сервере, настольном компьютере или других устройствах). 
- сервер авторизации (authorization server) - сервер, выдающий клиенту токены доступа после успешной аутентификации владельца ресурса и получения авторизации.
Взаимодействие между сервером авторизации и сервером ресурсов выходит за рамки этой спецификации. Сервер авторизации может быть тем же сервером, что и сервер ресурсов, или отдельным объектом. Один сервер авторизации может выдавать токены доступа, принимаемые несколькими серверами ресурсов.
### 1.2 Процесс работы протокола
```plantuml
participant client as "Client"
participant r_owner as "Resource owner"
participant auth as "Authorization server"
participant r_srv as "Resource server"

client -> r_owner: (A) Aithorization request
r_owner -> client: (B) Authorization grant

client -> auth: (C) Authorization grant
auth -> client: (D) Access token

client -> r_srv: (E) Access token
r_srv -> client: (F) Protected resource
```

Рисунок 1. Обобщённый процесс работы протокола

Обобщённый процесс работы протокола OAuth 2.0, показанный на рисунке 1, описывает взаимодействие между четырьмя ролями и включает в себя следующие этапы:
- (A) - Клиент запрашивает авторизацию у владельца ресурса. Запрос на авторизацию может быть направлен непосредственно владельцу ресурса (как показано на рисунке) или, предпочтительно, косвенно через сервер авторизации в качестве посредника.
- (B) - Клиент получает разрешение на авторизацию, которое представляет собой учетные данные, представляющие авторизацию владельца ресурса, выраженную с использованием одного из четырех типов разрешений, определенных в данной спецификации, или с использованием типа разрешения на продление. Тип предоставления авторизации зависит от метода, используемого клиентом для запроса авторизации, и типов, поддерживаемых сервером авторизации.
- (C) - Клиент запрашивает токен доступа, проходя аутентификацию на сервере авторизации и предоставляя разрешение на авторизацию.
- (D) - Сервер авторизации проверяет подлинность клиента и подтверждает предоставление разрешения на авторизацию и, если оно действительно, выдает токен доступа.
- (E) - Клиент запрашивает защищенный ресурс у сервера ресурсов и проходит аутентификацию, предъявляя access токен.
- (F) - Сервер ресурсов проверяет access токен и, если он действителен, выполняет запрос.
Предпочтительным способом для клиента получить разрешение на авторизацию от владельца ресурса (описанным в шагах (A) и (B)) является использование сервера авторизации в качестве посредника, что показано на рисунке 3 в разделе 4.1.
### 1.3 Разрешение авторизации (authorization grant)
Разрешение авторизации (authorization grant) - это учетные данные, представляющие собой разрешение владельца ресурса (на доступ к его защищенным ресурсам), используемое клиентом для получения токена доступа.  Эта спецификация определяет четыре типа разрешений - код авторизации, неявные учетные данные, пароль владельца ресурса и учетные данные клиента - а также механизм расширения для определения дополнительных типов.
#### 1.3.1 Код авторизации - Authorization Code
Код авторизации получается при использовании сервера авторизации в качестве посредника между клиентом и владельцем ресурса.  Вместо того, чтобы запрашивать авторизацию непосредственно у владельца ресурса, клиент направляет владельца ресурса на сервер авторизации (через свой пользовательский агент, как определено в [RFC2616]), который, в свою очередь, направляет владельца ресурса обратно клиенту с кодом авторизации.

Прежде чем направить владельца ресурса обратно клиенту с кодом авторизации, сервер авторизации проверяет подлинность владельца ресурса и получает авторизацию. Поскольку владелец ресурса проходит аутентификацию только с помощью сервера авторизации, учетные данные владельца ресурса никогда не передаются клиенту.

Код авторизации обеспечивает несколько важных преимуществ в плане безопасности, таких как возможность аутентификации клиента, а также передача токена доступа непосредственно клиенту без прохождения его через пользовательский агент владельца ресурса и потенциального предоставления его другим лицам, включая владельца ресурса.
#### 1.3.2 Неявный - Implicit
Неявное предоставление - это упрощенный поток кода авторизации, оптимизированный для клиентов, реализованный в браузере с использованием языка сценариев, такого как JavaScript.  В неявном потоке вместо выдачи клиенту кода авторизации клиенту напрямую выдается токен доступа (в результате авторизации владельца ресурса). Тип предоставления является неявным, поскольку никакие промежуточные учетные данные (такие как код авторизации) не выдаются (и впоследствии не используются для получения токена доступа).

При выдаче токена доступа во время процесса неявного предоставления **сервер авторизации не выполняет проверку подлинности клиента**.  В некоторых случаях **идентификатор клиента может быть подтвержден с помощью URI перенаправления**, используемого для передачи токена доступа клиенту.  Токен доступа может быть передан владельцу ресурса или другим приложениям, имеющим доступ к пользовательскому агенту владельца ресурса.

Неявные разрешения повышают оперативность и эффективность работы некоторых клиентов (например, клиента, реализованного в виде встроенного в браузер приложения), поскольку сокращают количество обращений туда и обратно, необходимых для получения токена доступа.  Однако это удобство следует сопоставлять с последствиями для безопасности использования неявных разрешений, таких как те, которые описаны в разделах 10.3 и 10.16, особенно когда доступен тип разрешения с помощью кода авторизации.
#### 1.3.3 Учетные данные пароля владельца ресурса -  Resource Owner Password Credentials
Учетные данные пароля владельца ресурса (т.е. имя пользователя и пароль) могут быть использованы непосредственно в качестве разрешения на авторизацию для получения токена доступа. Учетные данные следует использовать только при наличии высокой степени доверия между владельцем ресурса и клиентом (например, клиент является частью операционной системы устройства или приложения с высокими привилегиями), а также при недоступности других типов авторизации (например, кода авторизации).

Несмотря на то, что этот тип предоставления требует прямого доступа клиента к учетным данным владельца ресурса, учетные данные владельца ресурса используются для одного запроса и обмениваются на токен доступа.  Этот тип предоставления может избавить клиента от необходимости хранить учетные данные владельца ресурса для использования в будущем, заменив их на долговременный access токен или refresh токен.
#### 1.3.4 Учетные данные клиента -  Client Credentials
Учетные данные клиента (или другие формы аутентификации клиента) могут использоваться в качестве разрешения на авторизацию, когда область авторизации ограничена защищенными ресурсами, находящимися под контролем клиента, или защищенными ресурсами, предварительно согласованными с сервером авторизации.  Учетные данные клиента обычно используются для предоставления авторизации, когда клиент действует от своего имени (клиент также является владельцем ресурса) или запрашивает доступ к защищенным ресурсам на основе авторизации, предварительно согласованной с сервером авторизации.

### 1.4 Токен доступа - Access token
Токены доступа - это учетные данные, используемые для доступа к защищенным ресурсам.  Токен доступа - это строка, представляющая авторизацию, выданную клиенту.  Строка обычно непрозрачна для клиента.  Токены представляют собой определенные области и продолжительность доступа, предоставляемые владельцем ресурса и обеспечиваемые сервером ресурсов и сервером авторизации.

Токен может обозначать идентификатор, используемый для получения информации об авторизации, или может содержать информацию об авторизации поддающимся проверке образом (т.е. строку токена, состоящую из некоторых данных и подписи).  Для того чтобы клиент мог использовать токен, могут потребоваться дополнительные учетные данные для проверки подлинности, которые выходят за рамки данной спецификации.

Токен доступа обеспечивает уровень абстракции, заменяя различные конструкции авторизации (например, имя пользователя и пароль) единым токеном, понятным серверу ресурсов.  Эта абстракция позволяет выдавать токены доступа с более строгими ограничениями, чем разрешение на авторизацию, используемое для их получения, а также избавляет сервер ресурсов от необходимости разбираться в широком спектре методов аутентификации.

Токены доступа могут иметь различные форматы, структуры и методы использования (например, криптографические свойства) в зависимости от требований безопасности сервера ресурсов.  Атрибуты токена доступа и методы, используемые для доступа к защищенным ресурсам, выходят за рамки данной спецификации и определяются сопутствующими спецификациями, такими как [RFC6750].
### 1.5 Токен обновления - refresh token
Токены обновления - это учетные данные, используемые для получения токенов доступа. Токены обновления выдаются клиенту сервером авторизации и используются для получения нового токена доступа, когда текущий токен доступа становится недействительным или истекает срок его действия, или для получения дополнительных токенов доступа с идентичной или более узкой областью действия (токены доступа могут иметь меньший срок службы и меньше разрешений, чем разрешено владельцем ресурса). Выдача токена обновления является необязательной по усмотрению сервера авторизации. Если сервер авторизации выдает токен обновления, он включается при выдаче токена доступа (т.е. шаг (D) на рис. 1).

Токен обновления - это строка, представляющая авторизацию, предоставленную клиенту владельцем ресурса. Строка обычно непрозрачна для клиента. Токен обозначает идентификатор, используемый для получения информации об авторизации. В отличие от токенов доступа, токены обновления предназначены для использования только с серверами авторизации и **никогда не отправляются на серверы ресурсов**.

```plantuml
title Рисунок 2: Обновление и истечение токена доступа

participant client as "Client"
participant r_srv as "Resource server"
participant auth as "Authorization server"

client -> auth: (A) Authorization grant
auth -> client: (B) Access token & Refresh token
client -> r_srv: (C) Access token
r_srv -> client: (D) Protected resource
client -> r_srv: (E) Access token
r_srv -> client: (F) Ivalid token error
client -> auth: (G) Refresh token
auth -> client: (H) Access token & Optional refresh token
```
Процесс изображённый на рисунке 2 изображает следующий процесс:
- (A) - Клиент запрашивает access токен, проходя аутентификацию на сервере авторизации и предоставляя разрешение на авторизацию.
- (B) - Сервер авторизации проверяет подлинность клиента и подтверждает предоставление авторизации и, если она действительна, то выдает access токен и refresh токен.
- (C) - Клиент отправляет запрос на защищенный ресурс на сервер ресурсов, предъявляя access токен.
- (D) - Сервер ресурсов проверяет access токен и, если он действителен, выполняет запрос.
- (E) - Шаги (C) и (D) повторяются до тех пор, пока не истечет срок действия access токена.  Если клиент знает, что срок действия токена доступа истек, он переходит к шагу (G); в противном случае он запрашивает другой защищенный ресурс.
- (F) - Поскольку access токен недействителен, сервер ресурсов возвращает ошибку недопустимого токена.
- (G) - Клиент запрашивает новый access токен, проходя аутентификацию на сервере авторизации и предоставляя refresh токен. Требования к аутентификации клиента зависят от типа клиента и политик сервера авторизации.
- (H) - Сервер авторизации проверяет подлинность клиента и refresh, и, если он действителен, выдает новый access токен (и, необязательно, новый refresh).
Этапы (C), (D), (E) и (F) выходят за рамки этой спецификации, как описано в разделе 7.
### 1.6  Версии TLS
Всякий раз, когда в соответствии с данной спецификацией используется протокол безопасности транспортного уровня (TLS), соответствующая версия (или версии) TLS будет меняться с течением времени в зависимости от широкого распространения и известных уязвимостей в системе безопасности.  На момент написания этой статьи TLS версии 1.2 [RFC5246] является самой последней версией, но имеет очень ограниченную базу развертывания и может быть недоступен для внедрения.  TLS версии 1.0 [RFC2246] является наиболее широко используемой версией и обеспечит максимально широкую совместимость.

Реализации **МОГУТ** также поддерживать дополнительные механизмы безопасности транспортного уровня, которые отвечают их требованиям безопасности.
### 1.7 HTTP перенаправления
В этой спецификации широко используются HTTP-перенаправления, при которых клиент или сервер авторизации направляет пользовательский агент владельца ресурса в другое место назначения.  Хотя примеры в этой спецификации показывают использование кода состояния HTTP 302, любой другой метод, доступный через user-agent для выполнения этого перенаправления, разрешен и рассматривается как деталь реализации.
**Примечание**: используйте HTTP 303.
### 1.8 Совместимость
OAuth 2.0 предоставляет богатую инфраструктуру авторизации с четко определенными свойствами безопасности.  Однако, как богатая и легко расширяемая платформа с множеством дополнительных компонентов, сама по себе эта спецификация, вероятно, приведет к появлению широкого спектра несовместимых реализаций.

Кроме того, в этой спецификации частично или полностью не определены некоторые необходимые компоненты (например, регистрация клиента, возможности сервера авторизации, обнаружение конечных точек).  Без этих компонентов клиенты должны быть вручную и специально настроены для взаимодействия с определенным сервером авторизации и сервером ресурсов.

Эта платформа была разработана с явным расчетом на то, что в будущей работе будут определены предписывающие профили и расширения, необходимые для достижения полной функциональной совместимости в веб-масштабе.

### 1.9 Условные обозначения
Ключевые слова:
- "**ОБЯЗАН** - MUST", 
- "**ЗАПРЕЩЕНО** - MUST NOT",
- "**ТРЕБУЕТСЯ** - REQUIRED",
- "**ДОЛЖЕН** - SHALL", 
- "**НЕ ДОЛЖЕН** - SHALL NOT", 
- "**СТОИТ** - SHOULD", 
- "**НЕ СТОИТ** - SHOULD NOT", 
- "**РЕКОМЕНДОВАНО** - RECOMMENDED", 
- "**ВОЗМОЖНО** - MAY"
- "**НЕОБЯЗАТЕЛЬНО** - OPTIONAL" 
в данной спецификации следует интерпретировать так, как описано в [RFC2119].

В этой спецификации используется расширенная форма обратной связи (ABNF) [RFC5234].  Кроме того, ссылка на URI-правило включена из "Унифицированного идентификатора ресурса (URI): общий синтаксис" [RFC3986].

Некоторые термины, связанные с безопасностью, следует понимать в смысле, определенном в [RFC4949].  Эти термины включают, но не ограничиваются ими, "атака", "аутентификация", "авторизация", "сертификат", "конфиденциальность", "учетные данные", "шифрование", "идентификация", "знак", "подпись", "доверие", "проверка подлинности" и "проверьте".

Если не указано иное, все имена и значения параметров протокола чувствительны к регистру.

## 2 Регистрация клиента
Перед запуском протокола клиент регистрируется на сервере авторизации.  Средства, с помощью которых клиент регистрируется на сервере авторизации, выходят за рамки данной спецификации, но обычно включают взаимодействие конечного пользователя с регистрационной формой в формате HTML.

Регистрация клиента не требует прямого взаимодействия между клиентом и сервером авторизации.  При поддержке сервера авторизации регистрация может осуществляться с помощью других средств установления доверия и получения требуемых свойств клиента (например, URI перенаправления, тип клиента).  Например, регистрация может быть выполнена с использованием выданного самим пользователем или третьей стороной подтверждения, или сервером авторизации, выполняющим обнаружение клиента с использованием доверенного канала.
При регистрации клиента разработчику клиента **СТОИТ**:
- указать тип клиента, как описано в разделе 2.1,
- предоставить URI для перенаправления клиента, как описано в разделе 3.1.2, и
- указать любую другую информацию, требуемую сервером авторизации (например, название приложения, веб-сайт, описание, изображение логотипа, согласие с юридическими условиями).
### 2.1 Типы клиентов
OAuth определяет два типа клиентов в зависимости от их способности безопасно проходить аутентификацию на сервере авторизации (т.е. сохранять конфиденциальность своих учетных данных клиента).:

- **confidential** - клиенты, способные сохранять конфиденциальность своих учетных данных (например, клиент, реализованный на защищенном сервере с ограниченным доступом к учетным данным клиента), или способные выполнять безопасную аутентификацию клиента с использованием других средств.
- **public** - клиенты, неспособные сохранить конфиденциальность своих учетных данных (например, клиенты, выполняющиеся на устройстве, используемом владельцем ресурса, таком как установленное собственное приложение или приложение на базе веб-браузера), и неспособные обеспечить безопасную аутентификацию клиента с помощью любых других средств.

Определение типа клиента основано на определении сервером авторизации безопасной аутентификации и допустимых уровнях доступа к учетным данным клиента.  Сервер авторизации **НЕ СТОИТ** делать предположений о типе клиента.

Клиент может быть реализован в виде распределенного набора компонентов, каждый из которых имеет свой тип клиента и контекст безопасности (например,
распределенный клиент, содержащий как конфиденциальный серверный компонент, так и общедоступный браузерный компонент).  Если сервер авторизации не обеспечивает поддержку таких клиентов или не предоставляет рекомендаций относительно их регистрации, клиент **СТОИТ** зарегистрировать каждый компонент как отдельный клиент.

Эта спецификация была разработана на основе следующих профилей клиентов:
- Веб-приложение - это конфиденциальный клиент, работающий на веб-сервере.  Владельцы ресурсов получают доступ к клиенту через пользовательский интерфейс HTML, отображаемый в пользовательском агенте на устройстве, используемом владельцем ресурса.  Учетные данные клиента, а также любой токен доступа, выданный клиенту, хранятся на веб-сервере и недоступны владельцу ресурса.
- Приложение на основе пользовательского агента - это общедоступный клиент, в котором клиентский код загружается с веб-сервера и выполняется в пользовательском агенте (например, веб-браузере) на устройстве, используемом владельцем ресурса.  Данные протокола и учетные данные легко доступны (и часто видны) владельцу ресурса.  Поскольку такие приложения находятся в user-agent, они могут беспрепятственно использовать возможности user-agent при запросе авторизации.
- Собственное приложение - это общедоступный клиент, установленный и выполняющийся на устройстве, используемом владельцем ресурса.  Данные протокола и учетные данные доступны владельцу ресурса.  Предполагается, что любые учетные данные для аутентификации клиента, включенные в приложение, могут быть извлечены.  С другой стороны, динамически выдаваемые учетные данные, такие как токены доступа или обновления, могут обеспечить приемлемый уровень защиты.  Как минимум, эти учетные данные защищены от враждебных серверов, с которыми может взаимодействовать приложение.  На некоторых платформах эти учетные данные могут быть защищены от доступа к другим приложениям, расположенным на том же устройстве.

## 2.2 Идентификатор клиента
Сервер авторизации выдает зарегистрированному клиенту идентификатор клиента - уникальную строку, представляющую регистрационную информацию, предоставленную клиентом. Идентификатор клиента не является секретным; он доступен владельцу ресурса и **НЕ ДОЛЖЕН** использоваться отдельно для аутентификации клиента. Идентификатор клиента уникален для сервера авторизации.

Размер строки идентификатора клиента в данной спецификации не определен.  Клиенту следует избегать предположений о размере идентификатора. Сервер авторизации **СЛЕДУЕТ** документировать размер любого идентификатора, который он выдает.
## 2.3 Аутентификация клиента
Если тип клиента является конфиденциальным, клиент и сервер авторизации устанавливают метод аутентификации клиента, соответствующий требованиям безопасности сервера авторизации. Сервер авторизации **МОЖЕТ** принимать любую форму аутентификации клиента, соответствующую его требованиям безопасности.

Конфиденциальным клиентам обычно выдается (или устанавливается) набор учетных данных клиента, используемых для аутентификации на сервере авторизации (например, пароль, пара открытых/закрытых ключей).

Сервер авторизации **МОЖЕТ** установить метод аутентификации клиента с помощью общедоступных клиентов. Однако серверу авторизации **ЗАПРЕЩЕНО** полагаться на общедоступную аутентификацию клиента с целью идентификации клиента.

Клиенту **ЗАПРЕЩЕНО** использовать более одного метода аутентификации в каждом запросе.
### 2.3.1 Пароль клиента
Клиенты, у которых есть пароль клиента, могут использовать базовую схему аутентификации HTTP (Authorization: Basic base64(login:password)), как определено в [RFC2617], для аутентификации на сервере авторизации. Идентификатор клиента кодируется с использованием алгоритма кодирования "application/x-www-form-urlencoded" согласно приложению B, и закодированное значение используется в качестве имени пользователя; пароль клиента кодируется с использованием того же алгоритма и используется в качестве пароля.  Сервер авторизации **ДОЛЖЕН** поддерживать базовую схему аутентификации HTTP для аутентификации клиентов, которым был выдан пароль клиента.

Например (с дополнительными переносами строк только для отображения):

`Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3`

В качестве альтернативы сервер авторизации **МОЖЕТ** поддерживать включение учетных данных клиента в тело запроса, используя следующие параметры:

- **client_id** - **ТРЕБУЕТСЯ** - Идентификатор клиента, выданный клиенту в процессе регистрации, описанном в разделе 2.2.
- **client_secret** -  **ТРЕБУЕТСЯ** - Секрет клиента. Клиент **МОЖЕТ** опустить этот параметр, если секрет клиента представляет собой пустую строку.
Включение учетных данных клиента в текст запроса с использованием этих двух параметров **НЕ РЕКОМЕНДУЕТСЯ** и **ДОЛЖНО** быть ограничено клиентами, которые не могут напрямую использовать базовую схему аутентификации HTTP (или другие схемы аутентификации HTTP на основе пароля). Параметры могут передаваться только в теле запроса и их **ЗАПРЕЩЕНО** включать в URI запроса.

Например, запрос на обновление токена доступа (раздел 6) с передачей в теле запроса (с дополнительными переносами строк только для целей отображения).:
```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```
Сервер авторизации **ОБЯЗАН** требовать использования протокола TLS, как описано в разделе 1.6, при отправке запросов с использованием аутентификации по паролю.

Поскольку этот метод аутентификации клиента предполагает использование пароля, сервер авторизации **ОБЯЗАН** защищать любую конечную точку, использующую его, от атак методом перебора.
### 2.3.2 Другие методы аутентификации
Сервер авторизации **МОЖЕТ** поддерживать любую подходящую схему HTTP-аутентификации, соответствующую его требованиям безопасности. При использовании других методов аутентификации сервер авторизации **ОБЯЗАН** определить соответствие между идентификатором клиента (регистрационной записью) и схемой аутентификации.
## 2.4 Незарегистрированные клиенты
Данная спецификация не исключает использования незарегистрированных клиентов.  Однако использование таких клиентов выходит за рамки данной спецификации и требует дополнительного анализа безопасности и анализа влияния на совместимость.

## 3 Конечные точки протокола
В процессе авторизации используются две конечные точки сервера авторизации (HTTP-ресурсы):
- Конечная точка авторизации - используется клиентом для получения авторизации от владельца ресурса с помощью перенаправления user-agent'а.
- Конечная точка токена - используется клиентом для обмена разрешения на авторизацию на токен доступа, обычно с аутентификацией клиента.
- Конечная точка перенаправления - используется сервером авторизации для возврата ответов, содержащих учетные данные для авторизации, клиенту через пользовательский агент владельца ресурса.
Не каждый тип разрешений на авторизацию использует все конечные точки. Типы разрешений на расширение **МОГУТ** определять дополнительные конечные точки по мере необходимости.

### 3.1 Конечная точка авторизации
Конечная точка авторизации используется для взаимодействия с владельцем ресурса и получения разрешения на авторизацию. Сервер авторизации **ОБЯЗАН** сначала подтвердить личность владельца ресурса. Способ, с помощью которого сервер авторизации проверяет подлинность владельца ресурса (например, имя пользователя и пароль для входа в систему, сеансовые файлы cookie), выходит за рамки данной спецификации.

Способы, с помощью которых клиент получает информацию о местоположении конечной точки авторизации, выходят за рамки данной спецификации, но это местоположение обычно указывается в сервисной документации.

URI конечной точки **МОЖЕТ** содержать отформатированный (согласно приложению B) компонент запроса "application/x-www-form-urlencoded" (раздел 3.4 [RFC3986]), который ОБЯЗАН **быть** сохранен при добавлении дополнительных параметров запроса. URI конечной точки **ЗАПРЕЩЕНО** включать компонент fragment (т.е. часть после #, localhost/auth?client_id=client#username=test).

Поскольку запросы к конечной точке авторизации приводят к аутентификации пользователя и передаче учетных данных в виде открытого текста (в ответе HTTP), сервер авторизации **ОБЯЗАН** требовать использования протокола TLS, как описано в разделе 1.6, при отправке запросов к конечной точке авторизации.

Сервер авторизации **ОБЯЗАН** поддерживать использование HTTP-метода "GET" [RFC2616] для конечной точки авторизации и может также поддерживать использование метода "POST".

Параметры, отправленные без значения, должны обрабатываться так, как если бы они были исключены из запроса. Сервер авторизации **ОБЯЗАН** игнорировать нераспознанные параметры запроса. Запросу и ответу **ЗАПРЕЩЕНО** содержать дублирующиеся параметры.